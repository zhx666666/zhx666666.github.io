{"meta":{"title":"abilited","subtitle":"","description":"","author":"abilited","url":"https://ipvb.gitee.io/blog","root":"blog/"},"pages":[],"posts":[{"title":"springboot配置","slug":"springboot配置","date":"2021-01-25T04:14:59.000Z","updated":"2021-01-25T04:19:02.648Z","comments":true,"path":"2021/01/25/springboot配置/","link":"","permalink":"https://ipvb.gitee.io/blog/2021/01/25/springboot%E9%85%8D%E7%BD%AE/","excerpt":"","text":"配置文件中心思想如果想有修改xxxAutoConfiguration中的值,查看这个自动配置类所绑定的XXXProperties这个类肯定和xxx前缀的配置文件斤进行绑定着,在配置文件中修改xxx前缀开始的.属性即可步骤12345@Configuration(proxyBeanMethods = false)@Import(EnableWebMvcConfiguration.class)@EnableConfigurationProperties(WebMvcProperties.class) //找到这个类,查看这个类绑定的前缀,在配置文件中修改以这个前缀下的属性即可,这个属性就是被类所绑定的属性@Order(0)public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123;&#125; 12345@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)public class WebMvcProperties &#123; private String staticPathPattern = &quot;/**&quot;; ...&#125; 1234# 添加静态资源访问路径，一般用于放行资源，和controller无关spring: mvc: static-path-pattern: /res/** 1.文件类型1.1以前使用properties1.2现在使用yml1.2.1 简介YAML 是 “YAML Ain’t Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。 非常适合用来做以数据为中心的配置文件 1.2.2、基本语法 key: value；kv之间有空格 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 ‘#’表示注释 字符串无需加引号，如果要加，’’与””表示字符串内容 会被 转义/不转义 1.2.3 数据类型 字面量：单个的、不可再分的值。date、boolean、string、number、null k:v 对象：键值对的集合。map、hash、set、object 行内写法： k: &#123;k1:v1,k2:v2,k3:v3&#125; #或 k: k1: v1 k2: v2 k3: v3 12345678910* 数组：一组按次序排列的值。array、list、queue* &#96;&#96;&#96;yaml 行内写法： k: [v1,v2,v3] #或者 k: - v1 - v2 - v3 #### 1.2.4实例 12345678910@Component@ConfigurationProperties(prefix = &quot;testyml&quot;)@Datapublic class TestYml &#123; private Integer age; private String name; private Pet pet; private String[] arr; private Map&lt;String, List&lt;Pet&gt;&gt; listMap;&#125; 1234567891011121314151617testyml: name: &#x27;我 \\n 你&#x27;# &quot;&quot;不会转义 &#x27;&#x27;会转义 pet: &#123;health: 26,petName: 李白,love: 26&#125; #给对象绑定值 arr: - 李四 - 张三 - 王五 listMap: a: - &#123;health: 26,petName: 李白1,love: 26&#125; - &#123;health: 46,petName: 李白2,love: 26&#125; b: - &#123;health: 99,petName: 李白3,love: 26&#125; - &#123;health: 88,petName: 李白4,love: 26&#125; - petName: 李白6 age: 45 2.配置文件提示12345678910111213141516171819202122&lt;dependency&gt; &lt;!-- 文件绑定类是,文件提示绑定类中的属性,方便开发,但是不要部署到容器 配置处理器--&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt;&lt;!-- 排除--&gt; &lt;excludes&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Web开发1、SpringMVC自动配置概览Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置) The auto-configuration adds the following features on top of Spring’s defaults: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 内容协商视图解析器和BeanName视图解析器 Support for serving static resources, including support for WebJars (covered later in this document)). 静态资源（包括webjars） Automatic registration of Converter, GenericConverter, and Formatter beans. 自动注册 Converter，GenericConverter，Formatter Support for HttpMessageConverters (covered later in this document). 支持 HttpMessageConverters （后来我们配合内容协商理解原理） Automatic registration of MessageCodesResolver (covered later in this document). 自动注册 MessageCodesResolver （国际化用） Static index.html support. 静态index.html 页支持 Custom Favicon support (covered later in this document). 自定义 Favicon Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). 自动使用 ConfigurableWebBindingInitializer ，（DataBinder负责将请求数据绑定到JavaBean上） If you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. 不用@EnableWebMvc注解。使用 @Configuration + WebMvcConfigurer 自定义规则 If you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components. 声明 WebMvcRegistrations 改变默认底层组件 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 使用 @EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC 2、简单功能分析2.1、静态资源访问1、静态资源目录只要静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources 访问 ： 当前项目根路径/ + 静态资源名 原理： 静态映射/**。 请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面 改变默认的静态资源路径 123456spring: mvc: static-path-pattern: /res/** resources: static-locations: [classpath:/haha/] 2、静态资源访问前缀默认无前缀 123spring: mvc: static-path-pattern: /res/** 当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找 3、webjar自动映射 /webjars/** https://www.webjars.org/ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jquery&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 访问地址：http://localhost:8080/webjars/jquery/3.5.1/jquery.js 后面地址要按照依赖里面的包路径 4.欢迎页面 静态资源路径下 index.html 如果给项目添加前缀会影响到index.html默认页面 可以配置静态资源路径 但是不可以配置静态资源的访问前缀,否则导致 index.html不能被默认访问 spring: # mvc: # static-path-pattern: /res/** 这个会导致welcome page功能失效 resources: static-locations: [classpath:/haha/] 1234567891011* controller能处理&#x2F;index#### 5.自定义 favicon.icofavicon.ico放在静态资源目录下即可.&#96;&#96;&#96;ymlspring:# mvc:# static-path-pattern: &#x2F;res&#x2F;** 这个会导致 Favicon 功能失效 #### 6.静态资源配置原理 springboot启动时默认会加载 xxxAutoConfiguration类(自动装配) springMVC功能的自动配置类WebMvcAutoConfiguration,生效 ```java@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;) public class WebMvcAutoConfiguration {} 123456789* 给容器中配了什么呢* &#96;&#96;&#96;java @Configuration(proxyBeanMethods &#x3D; false) @Import(EnableWebMvcConfiguration.class) @EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;) @Order(0) public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123; 配置文件的相关的属性和xxx进行了绑定,WebMvcProPerties==spring.mvc,ResourceProperties==spring.resource,将这些类和配置文件进行绑定,修改配置文件即可,和被绑定的配置类的属性进行对应,如果以后想修改自动配置的值,可以修改配置类所绑定的配置文件即可 7.配置类中只有一个有参构造123456789101112131415161718192021 //有参构造器所有参数的值都会从容器中装配依赖//ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象//WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象//ListableBeanFactory beanFactory Spring的beanFactory//HttpMessageConverters 找到所有的HttpMessageConverters//ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。=========//DispatcherServletPath //ServletRegistrationBean 给应用注册Servlet、Filter.... public WebMvcAutoConfigurationAdapter(ResourceProperties resourceProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) &#123; this.resourceProperties = resourceProperties; this.mvcProperties = mvcProperties; this.beanFactory = beanFactory; this.messageConvertersProvider = messageConvertersProvider; this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable(); this.dispatcherServletPath = dispatcherServletPath; this.servletRegistrations = servletRegistrations; &#125; 8.默认配置的原则1234567891011121314151617181920212223242526@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; //如果设置了spring: //resources: // add-mappings: false #和这个addMappings属性进行绑定着,禁用所用静态资源 //springboot就会将虚拟路径映射到物理路径上了,这就是为什么能访问/webjars/**,就可以访问到下的静态资源文件了 if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; //静态资源缓存到浏览器的时间 Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) //缓存到浏览器的时间 .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125; 1234567891011@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)public class ResourceProperties &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; /** * Locations of static resources. Defaults to classpath:[/META-INF/resources/, * /resources/, /static/, /public/]. */ private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; 123456spring:# mvc:# static-path-pattern: /res/** resources: add-mappings: false 禁用所有静态资源规则 9.欢迎页处理原则1234567891011121314151617181920212223242526HandlerMapping:处理器映射 ，保存了每一个Handler能处理的请求，XXXMapping(&quot;/path&quot;)修饰的方法称为handler处理器 通过HanlderMapping得到用户请求路径找到相应的handler进行处理@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations()); return welcomePageHandlerMapping;&#125; WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123; //条件是 静态文件下是由有index.html页面,并且静态路径是/**,这就是为什么修改了 //spring.mvc.static-path-pattern=/res/** 默认页面不生效的原因 if (welcomePage.isPresent() &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)) &#123; logger.info(&quot;Adding welcome page: &quot; + welcomePage.get()); setRootViewName(&quot;forward:index.html&quot;); &#125; //如果有模板存在 `/` 就代表 controller /index的请求 else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123; logger.info(&quot;Adding welcome page template: index&quot;); setRootViewName(&quot;index&quot;); &#125; 3.请求映射处理0.请求映射1.使用rest使用于原理 @XXXMapping Rest风格支持(使用Http请求方式动词来表示对资源的操作) 以前：**/getUser 获取用户 /deleteUser 删除用户 /editUser 修改用户 /saveUser 保存用户 现在： /user GET-**获取用户 DELETE-**删除用户 PUT-**修改用户 POST-**保存用户 核心Filter；HiddenHttpMethodFilter 用法： 表单method=post，隐藏域 _method=put SpringBoot中手动开启 12345678910111213141516171819202122232425protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; HttpServletRequest requestToUse = request; /** 1.判断表达提交方式是不是Post, 2.获取表单中_method参数的值 3.进行转化大写行时 4.判断请求方式是存在, 5.HttpMethodRequestWrapper对象是HttpServletRequest的实现 6.将从表单元素中获取的请求方式,放入这个构造方法中，进行构建成对象,最后返回,这就是包装模式 7.将请求方式覆盖掉, 目的由于form表单中没有PUT DELETE方式,为了解决此问题,将POST请求方法从请求中获取_method参数的值, 进行覆盖 */ if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; request.getAttribute(&quot;javax.servlet.error.exception&quot;) == null) &#123; String paramValue = request.getParameter(this.methodParam); if (StringUtils.hasLength(paramValue)) &#123; String method = paramValue.toUpperCase(Locale.ENGLISH); if (ALLOWED_METHODS.contains(method)) &#123; requestToUse = new HiddenHttpMethodFilter.HttpMethodRequestWrapper(request, method); &#125; &#125; &#125; filterChain.doFilter((ServletRequest)requestToUse, response);&#125; 扩展：如何把_method 这个名字换成我们自己喜欢的。 @GetMapping(&quot;/user&quot;) public String userGet()&#123; return &quot;Get user....&quot;; &#125; @PostMapping(&quot;/user&quot;) public String userPost()&#123; return &quot;Post user....&quot;; &#125; @PutMapping(&quot;/user&quot;) public String userPut()&#123; return &quot;Put user....&quot;; &#125; @DeleteMapping(&quot;/user&quot;) public String userDelete()&#123; return &quot;Delete user....&quot;; &#125; 12345678910111213141516171819##### 主要使用过滤器来进行二次修改 HiddenHttpMethodFilter,按需使用&#96;&#96;&#96;Java &#x2F;&#x2F;如果使用自带的过滤器必须开启让这个组件注入到容器中 @Bean @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)&#x2F;&#x2F;如果容器中不存在这个类型的bean @ConditionalOnProperty(prefix &#x3D; &quot;spring.mvc.hiddenmethod.filter&quot;, name &#x3D; &quot;enabled&quot;, matchIfMissing &#x3D; false)&#x2F;&#x2F;将spring.mvc.hiddenmethod.filter.enabled&#x3D; true设置为true开启使用使用过滤器 默认值false public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123; return new OrderedHiddenHttpMethodFilter(); &#125;自定义@Bean &#x2F;&#x2F;使用自己配置的组件,自己配置获取请求参数k,来获取值public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123; HiddenHttpMethodFilter h&#x3D;new HiddenHttpMethodFilter(); h.setMethodParam(&quot;_m&quot;); return h;&#125; 2.result风格 表达提交会带上name为_method的值,一般这是二次包装后的提交方式 请求过来HiddenHttpMethodFiler拦截 请求是否正常,并且是POST 获取到_methods的值 兼容下请求,PUT DELETE PATCH 原生request(Post),包装模式requestWrapper重写了doMethod方法,返回值是传入值 多滤器链放行了是否用wrapper以后的方法调用getMethod时调用requestWrapper的. rest使用客户端工具​ 如PostMan直接发送PUT DELETE PATCH,无需使用filter 12345spring: mvc: hiddenmethod: filter: enabled: true #开启页面表单的Rest功能 3.映射原理SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet-》doDispatch（） 12345678910111213141516171819protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // 找到当前请求使用哪个Handler（Controller的方法）处理 mappedHandler = getHandler(processedRequest); //HandlerMapping：处理器映射。/xxx-&gt;&gt;xxxx ![](C:\\Users\\DELL\\blog\\source_posts\\springboot配置\\image (2).png) RequestMappingHandlerMapping：保存了所有@RequestMapping 和handler的映射规则。 ![](C:\\Users\\DELL\\blog\\source_posts\\springboot配置\\image (1).png) 所有的请求和请求映射的处理器都放在HandlerMapping中 springboot自动配置欢迎页面使用的处理器映射是WeIcomePageHandlerMapping 访问/ 会从这个处理器映射找到对应的handler,这个handler返回的视图就是forward:/index.html springboot自动装配了默认的RequestMappingHandlerMapping 请求进来,挨个从一组HandlerMapping中找到对应的handler进行处理 我们也可以自定义处理器映射，往容器中放入我们自定以的HandlerMapping 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; //帮所有的HandlerMapping放到这个handlerMappings集合里,循环着个集合，从这个集合中的HandlerMapping找到相应的handler for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null; &#125;//筛选的底层@Nullable protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123; List&lt;Match&gt; matches = new ArrayList&lt;&gt;(); //获取这个请求地址是这个的handler,不排除多个 List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath); if (directPathMatches != null) &#123; //放到matches中 addMatchingMappings(directPathMatches, matches, request); &#125; if (matches.isEmpty()) &#123; // No choice but to go through all mappings... addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request); &#125; if (!matches.isEmpty()) &#123; //默认使用第一个处理器 Match bestMatch = matches.get(0); if (matches.size() &gt; 1) &#123; //如果有多个将进行判断 Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request)); matches.sort(comparator); bestMatch = matches.get(0); if (logger.isTraceEnabled()) &#123; logger.trace(matches.size() + &quot; matching mappings: &quot; + matches); &#125; if (CorsUtils.isPreFlightRequest(request)) &#123; return PREFLIGHT_AMBIGUOUS_MATCH; &#125; Match secondBestMatch = matches.get(1); //如果这个请求(包含请求方式)能匹配到handler多个handler进行处理,将会包异常 //进行比较 if (comparator.compare(bestMatch, secondBestMatch) == 0) &#123; Method m1 = bestMatch.handlerMethod.getMethod(); Method m2 = secondBestMatch.handlerMethod.getMethod(); String uri = request.getRequestURI(); //springmvc要求同样的请求同样的请求方法,不能有多方法同时能处理 throw new IllegalStateException( &quot;Ambiguous handler methods mapped for &#x27;&quot; + uri + &quot;&#x27;: &#123;&quot; + m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;); &#125; &#125; request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod); handleMatch(bestMatch.mapping, lookupPath, request); return bestMatch.handlerMethod; &#125; else &#123; return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request); &#125; &#125; 3.普通参数与基本注解1.1、注解：@PathVariable、@RequestHeader、@ModelAttribute、@RequestParam、@MatrixVariable、@CookieValue、@RequestBody 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@RestControllerpublic class ParameterTestController &#123; // car/2/owner/zhangsan @GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;) public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String name, @PathVariable Map&lt;String,String&gt; pv, @RequestHeader(&quot;User-Agent&quot;) String userAgent, @RequestHeader Map&lt;String,String&gt; header, @RequestParam(&quot;age&quot;) Integer age, @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters, @RequestParam Map&lt;String,String&gt; params, @CookieValue(&quot;_ga&quot;) String _ga, @CookieValue(&quot;_ga&quot;) Cookie cookie)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();// map.put(&quot;id&quot;,id);// map.put(&quot;name&quot;,name);// map.put(&quot;pv&quot;,pv);// map.put(&quot;userAgent&quot;,userAgent);// map.put(&quot;headers&quot;,header); map.put(&quot;age&quot;,age); map.put(&quot;inters&quot;,inters); map.put(&quot;params&quot;,params); map.put(&quot;_ga&quot;,_ga); System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue()); return map; &#125; @PostMapping(&quot;/save&quot;) public Map postMethod(@RequestBody String content)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;content&quot;,content); return map; &#125; //1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd //2、SpringBoot默认是禁用了矩阵变量的功能 // 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。 // removeSemicolonContent（移除分号内容）支持矩阵变量的 //3、矩阵变量必须有url路径变量才能被解析 @GetMapping(&quot;/cars/&#123;path&#125;&quot;) public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low, @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand, @PathVariable(&quot;path&quot;) String path)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;low&quot;,low); map.put(&quot;brand&quot;,brand); map.put(&quot;path&quot;,path); return map; &#125; // /boss/1;age=20/2;age=10 @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;) public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge, @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;bossAge&quot;,bossAge); map.put(&quot;empAge&quot;,empAge); return map; &#125;&#125; 加入语雀，获得更好的阅读体验注册 或 登录 后可以收藏本文随时阅读，还可以关注作者获得最新文章推送 立即加入 05、Web开发 1、SpringMVC自动配置概览Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置) The auto-configuration adds the following features on top of Spring’s defaults: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 内容协商视图解析器和BeanName视图解析器 Support for serving static resources, including support for WebJars (covered later in this document)). 静态资源（包括webjars） Automatic registration of Converter, GenericConverter, and Formatter beans. 自动注册 Converter，GenericConverter，Formatter Support for HttpMessageConverters (covered later in this document). 支持 HttpMessageConverters （后来我们配合内容协商理解原理） Automatic registration of MessageCodesResolver (covered later in this document). 自动注册 MessageCodesResolver （国际化用） Static index.html support. 静态index.html 页支持 Custom Favicon support (covered later in this document). 自定义 Favicon Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). 自动使用 ConfigurableWebBindingInitializer ，（DataBinder负责将请求数据绑定到JavaBean上） If you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. 不用@EnableWebMvc注解。使用 @Configuration + WebMvcConfigurer 自定义规则 If you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components. 声明 WebMvcRegistrations 改变默认底层组件 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 使用 @EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC 2、简单功能分析2.1、静态资源访问1、静态资源目录只要静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources 访问 ： 当前项目根路径/ + 静态资源名 原理： 静态映射/**。 请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面 改变默认的静态资源路径 123456spring: mvc: static-path-pattern: &#x2F;res&#x2F;** resources: static-locations: [classpath:&#x2F;haha&#x2F;] 2、静态资源访问前缀默认无前缀 123spring: mvc: static-path-pattern: &#x2F;res&#x2F;** 当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找 3、webjar自动映射 /webjars/** https://www.webjars.org/ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jquery&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 访问地址：http://localhost:8080/webjars/jquery/3.5.1/jquery.js 后面地址要按照依赖里面的包路径 2.2、欢迎页支持 静态资源路径下 index.html 可以配置静态资源路径 但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问 123456spring:# mvc:# static-path-pattern: &#x2F;res&#x2F;** 这个会导致welcome page功能失效 resources: static-locations: [classpath:&#x2F;haha&#x2F;] controller能处理/index 2.3、自定义 Faviconfavicon.ico 放在静态资源目录下即可。 123spring:# mvc:# static-path-pattern: &#x2F;res&#x2F;** 这个会导致 Favicon 功能失效 2.4、静态资源配置原理 SpringBoot启动默认加载 xxxAutoConfiguration 类（自动配置类） SpringMVC功能的自动配置类 WebMvcAutoConfiguration，生效 12345678@Configuration(proxyBeanMethods &#x3D; false)@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123;&#125; 给容器中配了什么。 12345@Configuration(proxyBeanMethods &#x3D; false)@Import(EnableWebMvcConfiguration.class)@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)@Order(0)public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123;&#125; 配置文件的相关属性和xxx进行了绑定。WebMvcProperties==spring.mvc、ResourceProperties==spring.resources 1、配置类只有一个有参构造器123456789101112131415161718192021 &#x2F;&#x2F;有参构造器所有参数的值都会从容器中确定&#x2F;&#x2F;ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象&#x2F;&#x2F;WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象&#x2F;&#x2F;ListableBeanFactory beanFactory Spring的beanFactory&#x2F;&#x2F;HttpMessageConverters 找到所有的HttpMessageConverters&#x2F;&#x2F;ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;&#x2F;DispatcherServletPath &#x2F;&#x2F;ServletRegistrationBean 给应用注册Servlet、Filter.... public WebMvcAutoConfigurationAdapter(ResourceProperties resourceProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) &#123; this.resourceProperties &#x3D; resourceProperties; this.mvcProperties &#x3D; mvcProperties; this.beanFactory &#x3D; beanFactory; this.messageConvertersProvider &#x3D; messageConvertersProvider; this.resourceHandlerRegistrationCustomizer &#x3D; resourceHandlerRegistrationCustomizerProvider.getIfAvailable(); this.dispatcherServletPath &#x3D; dispatcherServletPath; this.servletRegistrations &#x3D; servletRegistrations; &#125; 2、资源处理的默认规则12345678910111213141516171819202122232425262728293031323334353637383940@Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Duration cachePeriod &#x3D; this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl &#x3D; this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); &#x2F;&#x2F;webjars的规则 if (!registry.hasMappingForPattern(&quot;&#x2F;webjars&#x2F;**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;) .addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#x2F;&#x2F; String staticPathPattern &#x3D; this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125;spring:# mvc:# static-path-pattern: &#x2F;res&#x2F;** resources: add-mappings: false 禁用所有静态资源规则@ConfigurationProperties(prefix &#x3D; &quot;spring.resources&quot;, ignoreUnknownFields &#x3D; false)public class ResourceProperties &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS &#x3D; &#123; &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;static&#x2F;&quot;, &quot;classpath:&#x2F;public&#x2F;&quot; &#125;; &#x2F;** * Locations of static resources. Defaults to classpath:[&#x2F;META-INF&#x2F;resources&#x2F;, * &#x2F;resources&#x2F;, &#x2F;static&#x2F;, &#x2F;public&#x2F;]. *&#x2F; private String[] staticLocations &#x3D; CLASSPATH_RESOURCE_LOCATIONS; 3、欢迎页的处理规则1234567891011121314151617181920212223242526HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping &#x3D; new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations()); return welcomePageHandlerMapping; &#125;WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123; if (welcomePage.isPresent() &amp;&amp; &quot;&#x2F;**&quot;.equals(staticPathPattern)) &#123; &#x2F;&#x2F;要用欢迎页功能，必须是&#x2F;** logger.info(&quot;Adding welcome page: &quot; + welcomePage.get()); setRootViewName(&quot;forward:index.html&quot;); &#125; else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123; &#x2F;&#x2F; 调用Controller &#x2F;index logger.info(&quot;Adding welcome page template: index&quot;); setRootViewName(&quot;index&quot;); &#125;&#125; 4、favicon3、请求参数处理0、请求映射1、rest使用与原理 @xxxMapping； Rest风格支持（使用HTTP请求方式动词来表示对资源的操作） 以前：**/getUser 获取用户 /deleteUser 删除用户 /editUser 修改用户 /saveUser 保存用户 现在： /user GET-**获取用户 DELETE-**删除用户 PUT-**修改用户 POST-**保存用户 核心Filter；HiddenHttpMethodFilter 用法： 表单method=post，隐藏域 _method=put SpringBoot中手动开启 扩展：如何把_method 这个名字换成我们自己喜欢的。 12345678910111213141516171819202122232425262728293031323334353637 @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.GET) public String getUser()&#123; return &quot;GET-张三&quot;; &#125; @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.POST) public String saveUser()&#123; return &quot;POST-张三&quot;; &#125; @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.PUT) public String putUser()&#123; return &quot;PUT-张三&quot;; &#125; @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.DELETE) public String deleteUser()&#123; return &quot;DELETE-张三&quot;; &#125; @Bean @ConditionalOnMissingBean(HiddenHttpMethodFilter.class) @ConditionalOnProperty(prefix &#x3D; &quot;spring.mvc.hiddenmethod.filter&quot;, name &#x3D; &quot;enabled&quot;, matchIfMissing &#x3D; false) public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123; return new OrderedHiddenHttpMethodFilter(); &#125;&#x2F;&#x2F;自定义filter @Bean public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123; HiddenHttpMethodFilter methodFilter &#x3D; new HiddenHttpMethodFilter(); methodFilter.setMethodParam(&quot;_m&quot;); return methodFilter; &#125; Rest原理（表单提交要使用REST的时候） 表单提交会带上_method=PUT 请求过来被HiddenHttpMethodFilter拦截 请求是否正常，并且是POST 获取到_method的值。 兼容以下请求；PUT.DELETE.PATCH 原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用**requesWrapper的。** **** Rest使用客户端工具， 如PostMan直接发送Put、delete等方式请求，无需Filter。 12345spring: mvc: hiddenmethod: filter: enabled: true #开启页面表单的Rest功能 2、请求映射原理 SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet-》doDispatch（） 12345678910111213141516171819protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest &#x3D; request; HandlerExecutionChain mappedHandler &#x3D; null; boolean multipartRequestParsed &#x3D; false; WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv &#x3D; null; Exception dispatchException &#x3D; null; try &#123; processedRequest &#x3D; checkMultipart(request); multipartRequestParsed &#x3D; (processedRequest !&#x3D; request); &#x2F;&#x2F; 找到当前请求使用哪个Handler（Controller的方法）处理 mappedHandler &#x3D; getHandler(processedRequest); &#x2F;&#x2F;HandlerMapping：处理器映射。&#x2F;xxx-&gt;&gt;xxxx RequestMappingHandlerMapping：保存了所有@RequestMapping 和handler的映射规则。 所有的请求映射都在HandlerMapping中。 SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html； SpringBoot自动配置了默认 的 RequestMappingHandlerMapping 请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。 如果有就找到这个请求对应的handler 如果没有就是下一个 HandlerMapping 我们需要一些自定义的映射处理，我们也可以自己给容器中放HandlerMapping。自定义 HandlerMapping 1234567891011protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings !&#x3D; null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler &#x3D; mapping.getHandler(request); if (handler !&#x3D; null) &#123; return handler; &#125; &#125; &#125; return null;&#125; 4.参数装配原理1、普通参数与基本注解1.1、注解：@PathVariable、@RequestHeader、@ModelAttribute、@RequestParam、@MatrixVariable、@CookieValue、@RequestBody 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@RestControllerpublic class ParameterTestController &#123; &#x2F;&#x2F; car&#x2F;2&#x2F;owner&#x2F;zhangsan @GetMapping(&quot;&#x2F;car&#x2F;&#123;id&#125;&#x2F;owner&#x2F;&#123;username&#125;&quot;) public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String name, @PathVariable Map&lt;String,String&gt; pv, @RequestHeader(&quot;User-Agent&quot;) String userAgent, @RequestHeader Map&lt;String,String&gt; header, @RequestParam(&quot;age&quot;) Integer age, @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters, @RequestParam Map&lt;String,String&gt; params, @CookieValue(&quot;_ga&quot;) String _ga, @CookieValue(&quot;_ga&quot;) Cookie cookie)&#123; Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; map.put(&quot;id&quot;,id);&#x2F;&#x2F; map.put(&quot;name&quot;,name);&#x2F;&#x2F; map.put(&quot;pv&quot;,pv);&#x2F;&#x2F; map.put(&quot;userAgent&quot;,userAgent);&#x2F;&#x2F; map.put(&quot;headers&quot;,header); map.put(&quot;age&quot;,age); map.put(&quot;inters&quot;,inters); map.put(&quot;params&quot;,params); map.put(&quot;_ga&quot;,_ga); System.out.println(cookie.getName()+&quot;&#x3D;&#x3D;&#x3D;&gt;&quot;+cookie.getValue()); return map; &#125; @PostMapping(&quot;&#x2F;save&quot;) public Map postMethod(@RequestBody String content)&#123; Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;(); map.put(&quot;content&quot;,content); return map; &#125; &#x2F;&#x2F;1、语法： 请求路径：&#x2F;cars&#x2F;sell;low&#x3D;34;brand&#x3D;byd,audi,yd &#x2F;&#x2F;2、SpringBoot默认是禁用了矩阵变量的功能 &#x2F;&#x2F; 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。 &#x2F;&#x2F; removeSemicolonContent（移除分号内容）支持矩阵变量的 &#x2F;&#x2F;3、矩阵变量必须有url路径变量才能被解析 @GetMapping(&quot;&#x2F;cars&#x2F;&#123;path&#125;&quot;) public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low, @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand, @PathVariable(&quot;path&quot;) String path)&#123; Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;(); map.put(&quot;low&quot;,low); map.put(&quot;brand&quot;,brand); map.put(&quot;path&quot;,path); return map; &#125; &#x2F;&#x2F; &#x2F;boss&#x2F;1;age&#x3D;20&#x2F;2;age&#x3D;10 @GetMapping(&quot;&#x2F;boss&#x2F;&#123;bossId&#125;&#x2F;&#123;empId&#125;&quot;) public Map boss(@MatrixVariable(value &#x3D; &quot;age&quot;,pathVar &#x3D; &quot;bossId&quot;) Integer bossAge, @MatrixVariable(value &#x3D; &quot;age&quot;,pathVar &#x3D; &quot;empId&quot;) Integer empAge)&#123; Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;(); map.put(&quot;bossAge&quot;,bossAge); map.put(&quot;empAge&quot;,empAge); return map; &#125;&#125; 1.2、Servlet API：WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId\\ 以上部分交给ServletRequestMethodArgumentResolver 进行给参数解析 12345678910111213141516@Override public boolean supportsParameter(MethodParameter parameter) &#123; Class&lt;?&gt; paramType = parameter.getParameterType(); return (WebRequest.class.isAssignableFrom(paramType) || ServletRequest.class.isAssignableFrom(paramType) || MultipartRequest.class.isAssignableFrom(paramType) || HttpSession.class.isAssignableFrom(paramType) || (pushBuilder != null &amp;&amp; pushBuilder.isAssignableFrom(paramType)) || Principal.class.isAssignableFrom(paramType) || InputStream.class.isAssignableFrom(paramType) || Reader.class.isAssignableFrom(paramType) || HttpMethod.class == paramType || Locale.class == paramType || TimeZone.class == paramType || ZoneId.class == paramType); &#125; 1.3 复杂参数Map、Model（map、model里面的数据会被放在request的请求域 request.setAttribute）、Errors/BindingResult、RedirectAttributes（ 重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder 12Map&lt;String,Object&gt; map, Model model, HttpServletRequest request 都是可以给request域中放数据，request.getAttribute(); Map、Model类型的参数，会返回 mavContainer.getModel（）；—&gt; BindingAwareModelMap 是Model 也是Map mavContainer.getModel(); 获取到值的 1.4 自定义参数对象可以自动类型转换格式，可以级联封装1234567891011121314151617181920212223242526/** * 姓名： &lt;input name=&quot;userName&quot;/&gt; &lt;br/&gt; * 年龄： &lt;input name=&quot;age&quot;/&gt; &lt;br/&gt; * 生日： &lt;input name=&quot;birth&quot;/&gt; &lt;br/&gt; * 宠物姓名：&lt;input name=&quot;pet.name&quot;/&gt;&lt;br/&gt; * 宠物年龄：&lt;input name=&quot;pet.age&quot;/&gt; */@Datapublic class Person &#123; private String userName; private Integer age; private Date birth; private Pet pet; &#125;@Datapublic class Pet &#123; private String name; private String age;&#125;result 2.POJO封装的过程 ServletModelAttributeMethodProcessor 3.参数处理原理 handelrMapping中找到能处理这个请求的handelr(Controller.method()) 给当前的Handler找一个对应的handlerAdapter;默认使用requestMapping修饰的handler会使用requestMappingHandlerAdpater,调用参数解析器进行给形参赋值 适配器执行目的方法并确定方法参数的每一个值 1.HandlerAdpater 0:支持方法上标注着RequestMapping的注解 1_支持函数编程的方法 xxxx 2.执行目标方法流程主要研究的方法123456789// Actually invoke the handler.//DispatcherServlet -- doDispatchmv = ha.handle(processedRequest, response, mappedHandler.getHandler());mav = invokeHandlerMethod(request, response, handlerMethod); //执行目标方法//ServletInvocableHandlerMethodObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);//将handler方法的值//获取方法的参数值Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); 流行123// Actually invoke the handler.真正的执行，将HandlerAdpater进行执行//DispatcherServlet -- doDispatchmv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 1mav = invokeHandlerMethod(request, response, handlerMethod);//获取ModelAndView对象 123456789101112131415161718192021222324252627282930313233343536373839//获取方法参数值protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; //获取方法中的参数对象 MethodParameter[] parameters = getMethodParameters(); //如果没参数直接返回,就不再找相应的参数解析器解析这个类型的参数了 if (ObjectUtils.isEmpty(parameters)) &#123; return EMPTY_ARGS; &#125; //创建一个长度为参数对象数量的数据组，用于将解析器解析参数的值放入此数组 Object[] args = new Object[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); args[i] = findProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; //判断是否有解析这个类型的参数解析器,如果没有接直接抛出异常 if (!this.resolvers.supportsParameter(parameter)) &#123; throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;)); &#125; try &#123; args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); &#125; catch (Exception ex) &#123; // Leave stack trace for later, exception may actually be resolved and handled... if (logger.isDebugEnabled()) &#123; String exMsg = ex.getMessage(); if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123; logger.debug(formatArgumentError(parameter, exMsg)); &#125; &#125; throw ex; &#125; &#125; return args; &#125; 12345678910//找到相应的参数解析器 HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);// 找到相应的参数解析器//底层就是循环判断那个参数解析器能解析这个类型的参数 for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123; if (resolver.supportsParameter(parameter)) &#123; result = resolver; this.argumentResolverCache.put(parameter, result);//缓存 break; &#125; &#125; 12345678//不同的参数解析器有不同的判断逻辑 public boolean supportsParameter(MethodParameter parameter) &#123; //判断这个参数石佛标注了RequestParam这个注解...,如果标注，满足这个解析器，就交给这个解析器进行解析if (parameter.hasParameterAnnotation(RequestParam这个注解,.class)) &#123; if (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123; RequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class); return (requestParam != null &amp;&amp; StringUtils.hasText(requestParam.name())); &#125; 123456789101112131415161718 @Override@Nullablepublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; //得到参数信息 NamedValueInfo namedValueInfo = getNamedValueInfo(parameter); MethodParameter nestedParameter = parameter.nestedIfOptional(); //获取参数名称 Object resolvedName = resolveStringValue(namedValueInfo.name); if (resolvedName == null) &#123; throw new IllegalArgumentException( &quot;Specified name must not resolve to null: [&quot; + namedValueInfo.name + &quot;]&quot;); &#125; //进行执行，底层就是根据resolvedName从请求对象中获取参数request.getParamValue(resolvedName) Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest); 1234567891011121314151617181920212223242526272829@Override@Nullableprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception &#123; HttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class); if (servletRequest != null) &#123; Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest); if (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123; return mpArg; &#125; &#125; Object arg = null; MultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class); if (multipartRequest != null) &#123; List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name); if (!files.isEmpty()) &#123; arg = (files.size() == 1 ? files.get(0) : files); &#125; &#125; if (arg == null) &#123; //根据参数名称获取参数值 String[] paramValues = request.getParameterValues(name); if (paramValues != null) &#123; arg = (paramValues.length == 1 ? paramValues[0] : paramValues); &#125; &#125; return arg;&#125; 3.参数解析器-HandlerMethodArgumentResolver确定将要执行目标方法的每一个参数值是什么 SpringMvc目标方法能写多少种类型的参数,取决于参数解析器 当前解析器是否支持解析这种参数 支持就调用 resolveArgument 4.返回值处理器","categories":[],"tags":[]},{"title":"springboot基础","slug":"springboot基础","date":"2021-01-25T04:14:52.000Z","updated":"2021-01-25T04:18:25.286Z","comments":true,"path":"2021/01/25/springboot基础/","link":"","permalink":"https://ipvb.gitee.io/blog/2021/01/25/springboot%E5%9F%BA%E7%A1%80/","excerpt":"","text":"springboot介绍为什么用SpringBootSpring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. 能快速创建出生产级别的Spring应用 SpringBoot优点 Create stand-alone Spring applications 创建独立Spring应用 Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 内嵌web服务器 Provide opinionated ‘starter’ dependencies to simplify your build configuration 自动starter依赖，简化构建配置 Automatically configure Spring and 3rd party libraries whenever possible 自动配置Spring以及第三方功能 Provide production-ready features such as metrics, health checks, and externalized configuration 提供生产级别的监控、健康检查及外部化配置 Absolutely no code generation and no requirement for XML configuration 无代码生成、无需编写XML SpringBoot是整合Spring技术栈的一站式框架 SpringBoot是简化Spring技术栈的快速开发脚手架 SpringBoot缺点 人称版本帝，更新快,需要时刻关注变化 封装太深,内部原理复杂，不容易精通 springboot2入门依赖1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建主程序1234567891011/** * 主程序类 * @SpringBootApplication：这是一个SpringBoot应用 */@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 编写业务1234567891011@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String handle01()&#123; return &quot;Hello, Spring Boot 2!&quot;; &#125;&#125; 简化部署12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 把项目打成jar包，直接在目标服务器执行即可。 注意点： 取消掉cmd的快速编辑模式 了解自动配置原理依赖管理 父工程最依赖管理 ```依赖管理 org.springframework.boot spring-boot-starter-parent 2.3.4.RELEASE 他的父项目 org.springframework.boot spring-boot-dependencies 2.3.4.RELEASE 几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制优点版本控制 12345678910111213141516* 开发导入starter场景启动器* &#96;&#96;&#96;xml 1、见到很多 spring-boot-starter-* ： *就某种场景 2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入 3、SpringBoot所有支持的场景 https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-boot&#x2F;docs&#x2F;current&#x2F;reference&#x2F;html&#x2F;using-spring-boot.html#using-boot-starter 4、见到的 *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。 5、所有场景启动器最底层的依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt; &lt;scope&gt;compile&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; 无需关注版本号 1、引入依赖默认都可以不写版本 2、引入非版本仲裁的jar，要写版本号。 123456789* 可以修改springboot默认提供的版本号* &#96;&#96;&#96; 1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。 2、在当前项目里面重写配置 &lt;properties&gt; &lt;mysql.version&gt;5.1.43&lt;&#x2F;mysql.version&gt; &lt;&#x2F;properties&gt; ### 自动配置 自动配好Tomcat 引入Tomcat依赖。 配置Tomcat 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt; &lt;scope&gt;compile&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; 自动配好SpringMVC 引入SpringMVC全套组件 自动配好SpringMVC常用组件（功能） 自动配好Web常见功能，如：字符编码问题 SpringBoot帮我们配置好了所有web开发的常见场景 默认的包结构 主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来 无需以前的包扫描配置 想要改变扫描路径，@SpringBootApplication(scanBasePackages=“com.atguigu”) 或者@ComponentScan 指定扫描路径 12345@SpringBootApplication等同于@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(&quot;com.atguigu.boot&quot;) 各种配置拥有默认值 默认配置最终都是映射到某个类上，如：MultipartProperties 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象 按需加载所有自动配置项 非常多的starter 引入了哪些场景这个场景的自动配置才会开启 SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面 …… 容器功能@Configuration 基本使用 Full模式与Lite模式 示例 最佳实战 配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断 配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#############################Configuration使用示例######################################################/** * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的 * 2、配置类本身也是组件 * 3、proxyBeanMethods：代理bean的方法 * Full(proxyBeanMethods = true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】 * Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的】 * 组件依赖必须使用Full模式默认。其他默认是否Lite模式 * * * */@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件public class MyConfig &#123; /** * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象 * @return */ @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例 public User user01()&#123; User zhangsan = new User(&quot;zhangsan&quot;, 18); //user组件依赖了Pet组件 zhangsan.setPet(tomcatPet()); return zhangsan; &#125; @Bean(&quot;tom&quot;) public Pet tomcatPet()&#123; return new Pet(&quot;tomcat&quot;); &#125;&#125;################################@Configuration测试代码如下########################################@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(&quot;com.atguigu.boot&quot;)public class MainApplication &#123; public static void main(String[] args) &#123; //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125; //3、从容器中获取组件 Pet tom01 = run.getBean(&quot;tom&quot;, Pet.class); Pet tom02 = run.getBean(&quot;tom&quot;, Pet.class); System.out.println(&quot;组件：&quot;+(tom01 == tom02)); //4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892 MyConfig bean = run.getBean(MyConfig.class); System.out.println(bean); //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。 //保持组件单实例 User user = bean.user01(); User user1 = bean.user01(); System.out.println(user == user1); User user01 = run.getBean(&quot;user01&quot;, User.class); Pet tom = run.getBean(&quot;tom&quot;, Pet.class); System.out.println(&quot;用户的宠物：&quot;+(user01.getPet() == tom)); &#125;&#125; @Bean、@Component、@Controller、@Service、@Repository@ComponentScan、@Import1234@Import(&#123;User.class, DBHelper.class&#125;) //给容器自动创建这两个类的组件@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件public class MyConfig &#123;&#125; @Conditional根据条件进行注入到容器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 编程人:赵浩鑫 * 时间:2021-01-02-14:20 * 设置服务时区,作用域mysql:set global time_zone =&#x27;+8:00&#x27;; */@Configuration(proxyBeanMethods = true)//表示这是spring配置类/** * proxyBeanMethods 是否使用代理 true 代理 默认值 重量级别 * false 非代理 轻量级 * 区别 重量级每次都判断容器是否存在此实例 ,多说的单例 *///@EnableConfigurationProperties(&#123;Car.class&#125;)/**1.开启指定类的配置绑定功能 * 2.把这个Car这个组件自动注入到容器 *///@ImportResource(&#123;&quot;classpath:beans.xml&quot;&#125;)//导入其它配置文件//@ConditionalOnClass(&#123;Person.class&#125;) //当满足条件在注册组件.当项目中存在这个类public class SpringConfig &#123; @Bean// @ConditionalOnMissingClass(Pet.class)//当项目中不存在这个类 public Pet pet()&#123; return new Pet(95, &quot;沐沐&quot;, 65); &#125; @Bean @ConditionalOnBean(name = &quot;pet&quot;)//如果容器中存在指定id的组件 然后再注入// @ConditionalOnMissingBean(name = &quot;pet01&quot;) 敲好相反// @ConditionalOnClass(value = &#123;Pet.class&#125;) public Student student()&#123; Student s=new Student(); s.setStuName(&quot;张三&quot;); s.setAge(15); s.setPet(pet()); return s; &#125; @Bean public Converter&lt;String, LocalDateTime&gt; LocalDateTimeConvert() &#123; return new Converter&lt;String, LocalDateTime&gt;() &#123; @Override public LocalDateTime convert(String source) &#123; DateTimeFormatter df = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); LocalDateTime date = null; try &#123; date = LocalDateTime.parse((String) source,df); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return date; &#125; &#125;; &#125; @ImportResource({“classpath:beans.xml”,….}) 导入以文件形式的配置配置绑定如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用； 12345678910111213public class getProperties &#123; public static void main(String[] args) throws FileNotFoundException, IOException &#123; Properties pps = new Properties(); pps.load(new FileInputStream(&quot;a.properties&quot;)); Enumeration enum1 = pps.propertyNames();//得到配置文件的名字 while(enum1.hasMoreElements()) &#123; String strKey = (String) enum1.nextElement(); String strValue = pps.getProperty(strKey); System.out.println(strKey + &quot;=&quot; + strValue); //封装到JavaBean。 &#125; &#125; &#125; @ConfigurationPropertie12345678910111213141516171819202122232425262728293031323334/** * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能 */@Component@ConfigurationProperties(prefix = &quot;mycar&quot;)//以配置文件以前缀mycar开始的属性和这个类的属性进行绑定,底层使用setXXXpublic class Car &#123; private String brand; private Integer price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public Integer getPrice() &#123; return price; &#125; public void setPrice(Integer price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;brand=&#x27;&quot; + brand + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125; @EnableConfigurationProperties + @ConfigurationProperties@Component + @ConfigurationProperties12345@EnableConfigurationProperties(Car.class)//1、开启Car配置绑定功能//2、把这个Car这个组件自动注册到容器中public class MyConfig &#123;&#125; 自动配置原理入门引导加载自动配置类123456789@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication&#123;&#125;====================== @SpringBootConfiguration​ @Configuration当表当前是一个配置类 @ComponentScan指定扫描包下类所标注的spring注解@EnableAutoConfiguration123@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;&#125; @AutoConfigurationPackage自动配置包,指定了默认的包规则1234567891011@Import(AutoConfigurationPackages.Registrar.class) //给容器中导入一系列组件public @interface AutoConfigurationPackage &#123;&#125;//利用Registrar给容器中导入一系列组件//将指定的一个包下的所有组件导入进来？MainApplication 所在包下。 public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; //获取注解所标注的类所在的包，然后进行扫描 register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0])); &#125; @Import(AutoConfigurationImportSelector.class)12345671、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件2、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类3、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件4、从META-INF/spring.factories位置来加载一个文件。 默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件 spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories 按需开启自动配置项12虽然我们127个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration按照条件装配规则（@Conditional），最终会按需配置。 修改用户所配置的组件,以防合法12345678910 @Bean @ConditionalOnBean(MultipartResolver.class) //容器中有这个类型组件 @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) //容器中没有这个名字 multipartResolver 的组件 public MultipartResolver multipartResolver(MultipartResolver resolver) &#123; //给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。 //SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范 // Detect if the user has created a MultipartResolver but named it incorrectly return resolver; &#125;给容器中加入了文件上传解析器； SpringBoot默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先1234@Bean @ConditionalOnMissingBean//表示容器中不存在这个组件,如果用户没有配置的话就用boot自动配置的 public CharacterEncodingFilter characterEncodingFilter() &#123; &#125; 总结 springboot 先加载所有的自动配置类 xxxAutoConfiguration 每个配置类按照条件进行纳入容器,默认都会绑定配置文件指定的值,xxxProperties.class里面拿,xxxProperties.class和配置文件进行绑定 生效的配置类就会给容器中装配很多组件 只要容器中有了这些组件，相当就有了这些功能 定制化配置 用户直接自己@Bean替代springboot底层的组件 用户可以看springboot自动配类所绑定的配置文件,用户只需改绑定的配置文件的值即可 例如 server.servlet.encoding.charset=utf-8 1234567 **xxxxxAutoConfiguration ---&gt; 组件 ---&gt;** **xxxxProperties里面拿值 ----&gt; application.properties**### 修改banner&#96;&#96;&#96;propertiesspring.banner.image.location&#x3D;classpath:(banner.*)默认值 ## 1.开发小技巧 1.1安装lombok简化web开发,一下是maven的依赖 1234567 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;idea中搜索安装lombok插件 1234567891011121314151617181920212223242526272829303132333435===============================简化JavaBean开发===================================@NoArgsConstructor//@AllArgsConstructor@Data@ToString@EqualsAndHashCodepublic class User &#123; private String name; private Integer age; private Pet pet; public User(String name,Integer age)&#123; this.name = name; this.age = age; &#125;&#125;================================简化日志开发===================================@Slf4j@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String handle01(@RequestParam(&quot;name&quot;) String name)&#123; log.info(&quot;请求进来了....&quot;); return &quot;Hello, Spring Boot 2!&quot;+&quot;你好：&quot;+name; &#125;&#125; 1.2dev-tools 重新如果源代码发生改变重新load123456 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 快捷键ctrl+f9","categories":[],"tags":[]},{"title":"spring","slug":"spring-1","date":"2021-01-25T04:05:40.000Z","updated":"2021-01-25T04:16:21.122Z","comments":true,"path":"2021/01/25/spring-1/","link":"","permalink":"https://ipvb.gitee.io/blog/2021/01/25/spring-1/","excerpt":"","text":"Spring简介Spring : 春天 —&gt;给软件行业带来了春天 2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。 2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。 很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。 Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术 优点1、Spring是一个开源免费的框架 , 容器 . 2、Spring是一个轻量级的框架 , 非侵入式的 . 3、控制反转 IoC , 面向切面 Aop 4、对事物的支持 , 对框架的支持 ioc控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 将组件对象的控制权从代码转移到外部容器(ioc) 组件化的思想:分离关注点 关注接口,不在关注实现类 目的:解耦合,实现每个组件只关注组件内部的事情 对内只关注本类的代码 对外只关注接口 1234567891011121314151617181920//注入ioc容器&lt;!--bean就是java对象,由Spring创建和管理--&gt;&lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;class是bean的全限定名=包名+类名--&gt;&lt;bean id=&quot;iphone&quot; class=&quot;org.ax.bean.Iphone&quot; p:weight=&quot;258&quot; p:money=&quot;8585&quot; p:size=&quot;5.9&quot; p:name=&quot;iphone Xs&quot;/&gt;&lt;bean id=&quot;student&quot; class=&quot;org.ax.bean.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;/&gt; &lt;property name=&quot;iphone&quot; ref=&quot;iphone&quot;/&gt; &lt;/bean&gt;&lt;bean id=&quot;ink&quot; class=&quot;org.ax.ink.GreyInk&quot;/&gt;&lt;bean id=&quot;page&quot; class=&quot;org.ax.page.imple.TestPage&quot;/&gt;&lt;bean id=&quot;print&quot; class=&quot;org.ax.print.Print&quot; p:ink-ref=&quot;ink&quot; p:page-ref=&quot;page&quot;/&gt; 123456789//配置类@Import(MyConfig2.class)//引用其它的配置类@Configurationpublic class MyConfig &#123; @Bean public Student student(@Qualifier(&quot;appearance&quot;) Appearance appearance)&#123; //通过Qualifier注解中的id或name进行装配 return new Student(1,appearance,&quot;张三&quot;,&quot;女&quot;); &#125;&#125; 123 applicationContext=new ClassPathXmlApplicationContext(&quot;springconfig.xml&quot;);//会对配置文件bean标签指定的class进行加载applicationContext。=new AnnotationConfigApplicationContext(MyConfig.class);//加载配置类 Student student=(Student)applicationContext.getBean(&quot;student&quot;/Class.class);//通过bean的id或类型获取bean 依赖注入 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 . &lt;!--P(属性: properties)命名空间 , 直接注入属性--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt; &lt;!--C(构造: Constructor)命名空间 , 使用构造器注入--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt; 12345678910111213141516171819202122## aop底层采用动态代理以及Aspectj技术在不修改目标方法的前提下,为目标方法增强新功能,**将公共功能集中解决**&#96;&#96;&#96;java&#x2F;&#x2F;日志通知对象public class LogAdvice &#123; Logger logger&#x3D; LoggerFactory.getLogger(getClass());&#x2F;&#x2F; 用于前置通知 public void before(JoinPoint joinPoint) throws Exception&#123; final Object target &#x3D; joinPoint.getTarget();&#x2F;&#x2F;获取目标对象 final Signature signature &#x3D; joinPoint.getSignature();&#x2F;&#x2F; System.out.println(signature.getModifiers()); logger.debug(&quot;执行的对象时...&quot;); &#125;&#x2F;&#x2F; 后置通知 public void after(JoinPoint joinPoint,Object result)&#123; System.out.println(&quot;后置通知..返回值&quot;+result); &#125;&#125; 12345678910111213&lt;!-- 连接点 通知--&gt; &lt;bean id=&quot;logAdvice&quot; class=&quot;org.ax.aop.LogAdvice&quot;/&gt; &lt;aop:config&gt;&lt;!-- 切入点--&gt;&lt;!-- &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* org.ax.bean.Student.*(..))&quot;/&gt;--&gt; &lt;aop:pointcut id=&quot;pointcut2&quot; expression=&quot;execution(* org.ax.bean.Student.add())&quot;/&gt;&lt;!-- 织入--&gt; &lt;aop:aspect ref=&quot;logAdvice&quot;&gt;&lt;!-- &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut2&quot;/&gt;--&gt; &lt;aop:after-returning method=&quot;after&quot; pointcut-ref=&quot;pointcut2&quot; returning=&quot;result&quot;/&gt; &lt;!--returning表示目标方法的返回值 --&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; ## p:命明空间注入和构造进行注入 1234567891011&lt;bean class=&quot;java.lang.String&quot; id=&quot;str&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;张三&quot;/&gt; &lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;org.ax.bean.Student&quot;&gt; &lt;constructor-arg name=&quot;name&quot; ref=&quot;str&quot;/&gt; //如果是包装类型或String引用类型可以使用ref引用进行依赖 &lt;constructor-arg name=&quot;1&quot; value=&quot;18&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.ObJect&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt;可以时用name执行参数名 index参数索引 type类型 等指定 注入不同数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 注入不同的引用类型--&gt; &lt;bean id=&quot;myCollection&quot; class=&quot;org.ax.bean.MyCollection&quot;&gt;&lt;!-- 给set集合进行赋值--&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;李白&lt;/value&gt; &lt;value&gt;杜甫&lt;/value&gt; &lt;value&gt;王安石&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;!-- 给properties类型注入值 值是值类型--&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props &gt; &lt;prop key=&quot;k1&quot;&gt;雨天&lt;/prop&gt; &lt;prop key=&quot;k2&quot;&gt;晴天&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;str&quot; /&gt;&lt;!-- 如果没有被其它bean所依赖可以写到内部--&gt; &lt;bean class=&quot;org.ax.bean.Student&quot; &gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;李白&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;26&quot;/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;mapk1&quot;&gt; &lt;value&gt;wd&lt;/value&gt; &lt;/entry&gt; &lt;entry key=&quot;mapk2&quot;&gt; &lt;ref bean=&quot;student&quot; /&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;args&quot;&gt; &lt;array&gt; &lt;value&gt;wda&lt;/value&gt; &lt;value&gt;wdad&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 自动装配的注解 @Autowired 先根据类型然后根据id进行装配 @Resource 先根据id然后根据类型进行装配,可以根据name属性指定bean的id @Qualifier(“bean的id”)进行装配 通过注解纳入ioc 注解的参数”bean的id 默认类名首字母小写”，通过不同的注解进行标识bean层次， @Component 一般标注bean @Service 标识业务层 @Controller 标识控制层 @Repository 持久层 12&lt;!-- 扫描包下的类所标注的注解,纳入容器 --&gt; &lt;context:component-scan base-package=&quot;org.ax.bean&quot; /&gt; 12345678910@Component(&quot;student3&quot;)//通过注解纳入iocpublic class Student &#123; @Value(&quot;张楠&quot;)//设置属性的值 private String name; @Value(&quot;15&quot;) private Integer age; @Autowired //想要将容器中的额bean注入进来 首先本类必须纳入ioc private Bean age; &#125; 环绕通知123456789101112131415161718//环绕增强将掌握的目标方法的执行权public class LogAround &#123; public Object around(ProceedingJoinPoint point)&#123; Object result=&quot;wd&quot;; try &#123; System.out.println(&quot;&lt;环绕&gt; 前置通知&quot;); result=point.proceed(); System.out.println(&quot;&lt;环绕&gt; 后置通知&quot;); &#125; catch (Throwable throwable) &#123; System.out.println(&quot;&lt;环绕&gt; 异常通知&quot;); throwable.printStackTrace(); &#125;finally &#123; System.out.println(&quot;&lt;环绕&gt; 最终通知,结果:&quot;+result); &#125; return result; &#125;&#125; 12345678910&lt;!-- 将增强功能纳入ioc容器--&gt; &lt;bean id=&quot;logAround&quot; class=&quot;org.ax.aop.LogAround&quot;/&gt; &lt;aop:config&gt;&lt;!-- 配置连接点--&gt; &lt;aop:pointcut id=&quot;ps1&quot; expression=&quot;execution(* org.ax.bean.Student.sayHello(..))&quot;/&gt;&lt;!-- 织入--&gt; &lt;aop:aspect ref=&quot;logAround&quot;&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;ps1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 注解版增强1234567891011121314151617181920212223@Component //纳入ioc容器中@Aspect //织入增强public class AroundAnnotations &#123; @Before(&quot;execution(* org.ax.bean.Student.sayHello(..))&quot;)//前置通知 public void before(JoinPoint joinPoint)&#123; System.out.println(&quot;注解版的前置通知...&quot;); &#125; @Around(&quot;execution(* org.ax.bean.Student.sayHello(..))&quot;)//环绕通知 public Object around(ProceedingJoinPoint point)&#123; Object result=null; try &#123; System.out.println(&quot;&lt;环绕通知&gt; : 注解版的前置通知...&quot;); result= point.proceed(); System.out.println(&quot;&lt;环绕通知&gt; : 注解版的后置通知...&quot;); &#125; catch (Throwable throwable) &#123; System.out.println(&quot;&lt;环绕通知&gt; : 注解版的异常通知...&quot;); throwable.printStackTrace(); &#125;finally &#123; System.out.println(&quot;&lt;环绕通知&gt; : 注解版的最终通知...，结果:&quot;+result); &#125; return result; &#125;&#125; 12&lt;!--启动注解版的通知--&gt; &lt;aop:aspectj-autoproxy/&gt; spring整合Mybatis-servlet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;spring-mybatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt;&lt;!-- db--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.22&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt;&lt;!-- dao--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.16&lt;/version&gt; &lt;/dependency&gt;&lt;!-- mybatis整合spring主要所用到SqlSessionFactoryBean--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;!-- service--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt;&lt;!-- spring-web 提供ContextClassListener启动器来加载工厂spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 提供了事务管理器 也可以使用spring-jdbc(core,bean,tx)此包中找不到java.lang.NoClassDefFoundError: org/springframework/jdbc/datasource/TransactionAwareDataS会报异常错误--&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.springframework&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!-- controller 控制器--&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;javax&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;8.0.1&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt;&lt;!-- view部分--&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;jstl&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;jstl&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;1.2&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt;&lt;!-- 测试部分--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 整合引入jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;!-- 引入嵌入式的Servlet--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.4.30.v20200611&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 通过配置类整合Mybatis12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package org.ax.config;import com.alibaba.druid.pool.DruidDataSource;import lombok.SneakyThrows;import org.ax.pojo.Role;import org.ax.pojo.User;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.annotation.Resource;import javax.sql.DataSource;/** * 编程人:赵浩鑫 * 时间:2020-12-29-09:51 * 设置服务时区,作用域mysql:set global time_zone =&#x27;+8:00&#x27;; */@Configuration@MapperScan(&quot;org.ax.mapper&quot;)//将映射文件所对应的映射器纳入Ioc,生成代理对象@ComponentScan(basePackages = &quot;org.ax.service&quot;)//扫描包下类所标注的注解，纳入容器public class SpringConfig &#123; @Bean //配置数据源 public DataSource dataSource()&#123; DruidDataSource dataSource=new DruidDataSource(); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/mvcmybatis?serverTimezone=UTC&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; @Bean //配置匹配资源bean public PathMatchingResourcePatternResolver patternResolver()&#123; return new PathMatchingResourcePatternResolver(); &#125; @SneakyThrows //lombok提供的用注解捕捉异常,提高代码层次 @Bean //配置sqlSesionFactoryBean,依赖mybatis配置文件和映射文件,数据源 public SqlSessionFactoryBean sqlSessionFactoryBean()&#123; SqlSessionFactoryBean sf=new SqlSessionFactoryBean(); sf.setDataSource(dataSource()); sf.setConfigLocation(patternResolver().getResource(&quot;classpath:mybatis-config.xml&quot;)); sf.setMapperLocations(patternResolver().getResources(&quot;classpath:mapper/*.xml&quot;)); return sf; &#125; @Bean(&quot;role1&quot;) public Role role1()&#123; return new Role(1, &quot;幻影&quot;); &#125; @Bean(&quot;role2&quot;) public Role role2()&#123; return new Role(1, &quot;幻影2&quot;); &#125;// 参数默认按照类型装配,如果出现出现多种bean的话，可以同通过形参名来执行ref=&quot;bean的id&quot;,// 或者指定@Qualifier(&quot;role1&quot;)注解指定ref指定的id @Bean public User user(@Qualifier(&quot;role1&quot;) Role a)&#123; User user=new User(); user.setRole(a); user.setUsername(&quot;李三&quot;); return user; &#125;&#125; 通过web.xml方式加载spring容器123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;listener&gt;&lt;!-- 防止重复加载，出现多个对象 web容器启动时,默认会加载相对路径下的application.xml文件--&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 接受带注解的类作为输入 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 指明配置配的路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;org.ax.config.SpringConfig&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 加载springmvc容器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;org.ax.config.WebConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 通过类加载SSM容器123456789101112131415161718192021222324public class OcrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; SpringConfig.class &#125;;//指定的spring配置 &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; MvcConfig.class &#125;; //ָ指定Web配置 &#125; @Override protected String[] getServletMappings() &#123; //将DispatcherServlet映射到&quot;/&quot; return new String[] &#123; &quot;/&quot; &#125;; &#125;&#125; laytpllaytpl 是 JavaScript 模板引擎，在字符解析上有着比较出色的表现，欠缺之处在于异常调试上。由于传统意义的前端模板引擎已经变得不再流行，所以 laytpl 后续可能会进行重写，目前方向暂时还没有想好，预计会在layui比较稳定后开始实施。与一般的字符拼接不同的是，laytpl 的模板可与数据分离，集中把逻辑处理放在 View 层，提升代码可维护性，尤其是针对大量模板渲染的情况。12345678910111213141516171819202122layui.use(&#x27;laytpl&#x27;, function()&#123; var laytpl = layui.laytpl; //直接解析字符 laytpl(&#x27;&#123;&#123; d.name &#125;&#125;是一位公猿&#x27;).render(&#123; name: &#x27;贤心&#x27; &#125;, function(string)&#123; console.log(string); //贤心是一位公猿 &#125;); //你也可以采用下述同步写法，将 render 方法的回调函数剔除，可直接返回渲染好的字符 var string = laytpl(&#x27;&#123;&#123; d.name &#125;&#125;是一位公猿&#x27;).render(&#123; name: &#x27;贤心&#x27; &#125;); console.log(string); //贤心是一位公猿 //如果模板较大，你也可以采用数据的写法，这样会比较直观一些 laytpl([ &#x27;&#123;&#123; d.name &#125;&#125;是一位公猿&#x27; ,&#x27;其它字符 &#123;&#123; d.content &#125;&#125; 其它字符&#x27; ].join(&#x27;&#x27;))&#125;); * 事务1234567// 配置事务,依赖数据源 并将类中加@EnableTransactionManagement//开启事务管理器 @Bean public DataSourceTransactionManager dataSourceTransactionManager()&#123; DataSourceTransactionManager d=new DataSourceTransactionManager(); d.setDataSource(dataSource()); return d; &#125; @Transactional 所标注的类下的所有方法具有事务，如果标注方法上只有这个方法具有事务,一般针对于方法指定不同的传播机制 readOnly true表示只读 false表示读写默认, 如果此业务方法只用于查询的话设置为只读型性能会提升 rollbackFor表示什么时机的异常或情况下触发回滚事务 默认三种情况下会自动回滚 error 错误 runtimeException运行时异常 执行sql语句时错误时 propagation事务传播机制 12345678/** Propagation.REQUIRED如果存在事务就支持当前事务,否则新建事务 默认值 * Propagation.REQUIRES_NEW创建一个事务覆盖原来的事务,不管原来存不存在 * Propagation.SUPPORTS如果存在事务,支持当前事务,否则按照非事务进行执行 * Propagation.NOT_SUPPORTED表示以非事务方式执行,如果存在事务,则挂起这个事务,按照非事务方法执行 * Propagation.MANDATORY如果不存在事务则抛出异常 * Propagation.NESTED如果存在一个事务,则创建这个事务的子事务 * Propagation.NEVER总以非事务方法执行,如果存在活动事务则抛出异常 */ isolation事务隔离等级 1234567/** * Isolation.READ_COMMITTED提交读 * Isolation.READ_UNCOMMITTED未提交读 * Isolation.REPEATABLE_READ可重复读 * Isolation.SERIALIZABLE串行读写 */ springmvc DispatcheServlet 一个请求匹配前端控制器DispatcheServlet在web.xml中所配置映射路径, /代表根路径下的一切请求 DispatcheServlet接受到请求后,将根据请求信息交给处理器映射器(HandlerMapping) HandlerMapping根据用户的的url请求查找匹配该url的Handler,并返回以执行链 DispatcheServlet再次请求处理器适配器(HandlerAdapter)调用相应的handler进行处理并返回给ModelAndView给DispatcheServlet DispatcheServlet将ModelAndView请求ViewReslover(视图解析器)解析,返回具体的view DispatcheServlet对View进行渲染(将数据填充视图中) 将页面响应给用户 流程 用户发送请求到DispatcheServlet,委托其它组件进行真正的处理,从一组HandlerMapping中找handler,前端处理器通过处理器适配器包装后执行Handler对象,Handler处理完业务逻辑，返回ModelAndView对象，其中view是视图名称，不是真正的视图对象,如果是逻辑路径,则通过视图解析器解析成物理路径,前端控制器根据模型数据和视图对象，进行视图渲染,渲染成html页面响应给用户客户端 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!-- Spring MVC servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; 开启注解版的注入 因为配置类是基于注解的 &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;org.ax.config.WebConfig&lt;/param-value&gt; &lt;/init-param&gt; 当启动容器时候加载配置 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 1234567891011121314151617181920212223242526@EnableWebMvc/** * handlerMapping处理器映射器 找到对相应的处理器handler @RequestMapping所标标注的方法 * HandlerAdapter处理器适配器 包装(request请求对象的参数)数据之后执行handler 返回ModelAndView * 如果view是逻辑路径会通过视图解析器解析,然后进行渲染成html页面 */@Configuration//配置类@ComponentScan(&quot;org.ax.controller&quot;)//包扫描器,扫描包下的类所标注的spring的注解@EnableCaching//开启springmvc的缓存public class WebConfig &#123; @Bean //配置内部资源视图解析器 public InternalResourceViewResolver viewResolver()&#123; InternalResourceViewResolver i=new InternalResourceViewResolver(); i.setPrefix(&quot;/WEB-INF/page/&quot;); i.setSuffix(&quot;.jsp&quot;); return i; &#125; @Bean//配置springmvc中的缓存,来缓存requsetMapping public ConcurrentMapCacheManager concurrentMapCacheManager()&#123; ConcurrentMapCacheManager c=new ConcurrentMapCacheManager(); List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add(&quot;userList&quot;); c.setCacheNames(list);//缓存的名称 return c; &#125;&#125; springmvc注解 @Controller将控制层注入到springmvc RequestMapping 路径映射 path或value映射的地址 method 请求方式 headers 请求头信息 produces设置字符编码 GetMapping相当于 get方式的RequestMapping PostMapping相当于 Post方式的RequestMapping ResponseBody响应数据，一般用于ajax,不会对ModelAndView进行处理 相当于传统servlet中的Print Writer对象,返回值就相当于print方法的参数() print方法 参数只能是字符串,由转化器会把pojo对象转成json格式的字符串 redirect表示为重定向:请求对象会消失，会忽略视图解析 forward表示为转发:因为会把第一次的请求进行了转发，会保存请求对对象会忽略视图解析 自定义消息信息转发器由于springmvc默认配置是jackJson的使用jackJson的可以不用配置,自定配置如下1234567891011121314151617@Bean //Jackson配置方式 public MappingJackson2HttpMessageConverter jackson()&#123; MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); jackson2HttpMessageConverter.setDefaultCharset(Charset.forName(&quot;utf-8&quot;)); ObjectMapper objectMapper = new ObjectMapper(); JavaTimeModule timeModule = new JavaTimeModule();// 配置时间格式 timeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;))); timeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))); objectMapper.registerModule(timeModule); StringHttpMessageConverter s=new StringHttpMessageConverter(); //设置字符转化器 s.setDefaultCharset(Charset.forName(&quot;utf-8&quot;)); jackson2HttpMessageConverter.setObjectMapper(objectMapper); return jackson2HttpMessageConverter; &#125; 阿里的FastJson12345678910111213141516171819 @Bean //配置阿里的fastJson数据格式 public FastJsonHttpMessageConverter fastJson()&#123; //1.需要定义一个convert转换消息的对象; FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();// fastJsonHttpMessageConverter.setDefaultCharset(Charset.forName(&quot;utf-8&quot;));//json字符编码 //2.添加fastJson的配置信息，比如：是否要格式化返回的json数据; FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);// fastJsonConfig.setCharset(Charset.forName(&quot;utf-8&quot;)); fastJsonConfig.setDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); //3处理中文乱码问题 List&lt;MediaType&gt; fastMediaTypes = new ArrayList&lt;&gt;(); fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8); //4.在convert中添加配置信息. fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes); fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig); return fastJsonHttpMessageConverter; &#125; 重新定义转化器格式重写WebMvcConfigurer接口下的configureMessageConverters123456 @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; //add添加消息转化器// converters.add(jackson()); converters.add(fastJson());//阿里jsonhttp消息转换器 &#125; 日期格式扩点12@DateTimeFormat(pattern = &quot;yyyy-MM-dd&#x27;T&#x27;HH:mm&quot;) //同步方式流入流出,是为了解析表单数据的（form/data)数据。@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm&quot;) //ajax异步方式流入流出日期歌格式进行转换 spring缓存机制123456789@Bean//配置springmvc中的缓存,来缓存requsetMappingpublic ConcurrentMapCacheManager concurrentMapCacheManager()&#123; ConcurrentMapCacheManager c=new ConcurrentMapCacheManager(); List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add(&quot;userList&quot;);//缓存的map c.setCacheNames(list);//缓存的名称 return c;&#125;在配置类中标注@EnableCaching//开启spring的缓存 @Cacheable( cacheNames=”缓存的名字”)： 加在方法上 在执行该方法之前，先检查缓存中是否有这条记录，如果有，则直接返回缓存中的记录，不执行该方法，若该缓存中没有存储该条记录，则执行该方法，将该方法的返回值存入该缓存中，以便于下一次的查找； @CacheEvict( cacheNames = “缓存名字”，allEntries = true) : 加在方法上 （allEntries: 该缓存中的所有记录） 将该缓存下的所有记录都清空 @CachePut( cacheNames=”缓存名字”)：加在方法上 总是会执行该方法，每次都把返回结果更新进该缓存中 从3.1开始，Spring引入了对Cache的支持。其使用方法和原理都类似于Spring对事务管理的支持。Spring Cache是作用在方法上的，其核心思想是这样的：当我们在调用一个缓存方法时会把该方法参数和返回结果作为一个键值对存放在缓存中，等到下次利用同样的参数来调用该方法时将不再执行该方法，而是直接从缓存中获取结果进行返回。所以在使用Spring Cache的时候我们要保证我们缓存的方法对于相同的方法参数要有相同的返回结果。spring还为我们提供了一个root对象可以用来生成key。通过该root对象我们可以获取到以下信息。 属性名称 描述 示例 methodName 当前方法名 #root.methodName method 当前方法 #root.method.name target 当前被调用的对象 #root.target targetClass 当前被调用的对象的class #root.targetClass args 当前方法参数组成的数组 #root.args[0] caches 当前被调用的方法使用的Cache #root.caches[0].name 1234567891011121314151617181920212223242526272829303132333435363738@RestController@RequestMapping(&quot;/contact&quot;)public class ContactController &#123; @Autowired ContactMapper contactMapper; @RequestMapping(&quot;/byId&quot;) @Cacheable(cacheNames = &quot;contact&quot;,key = &quot;#p0&quot;,condition = &quot;#id!=0&quot;) /** * cacheNames或者value：表示注解缓存区域的名称 * key:区域中的键 支持SpringEL p0表示第一个参数...或者 用形参名执行指定 * condition:当满足扫描条件进行缓存 */ public Contact byId(Integer id)&#123; System.out.println(&quot;执行了控制器&quot;); return contactMapper.findByContactId(id); &#125; @RequestMapping(&quot;/update&quot;) @CachePut(value = &quot;contact&quot;,key = &quot;#id&quot;)//每次都会执行方法，并将结果存入指定的缓存中,一般用于更新 public Contact update(Integer id)&#123; Contact contact=new Contact(); contact.setName(&quot;哈哈&quot;); contact.setId(id); return contact; &#125; //清理缓存 @CacheEvict(value=&quot;contact&quot;,allEntries = true) /** * allEntries true 删除缓存所有 * false 删除缓存指定的key 默认值 */ @RequestMapping(&quot;/delete&quot;) public String delete(Integer id) &#123; return &quot;delete..&quot;; &#125;&#125; SSM整合1.依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;packaging&gt;war&lt;/packaging&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.22&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dao--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring整合mybatis ,所提供的sqlSessionFactoryBean--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 依赖于事务jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 业务层--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据格式json默认以经配置好了 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试jar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 依赖底层最基础的jar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;layui&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.4.30.v20200611&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2.配置Spring12345678910111213141516171819202122232425262728293031323334353637383940414243@Configuration@ComponentScan(&quot;org.ax.service&quot;)//将service扫描到容器@MapperScan(basePackages = &quot;org.ax.mapper&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactoryBean&quot;)//将mapper映射器纳入容器供service调用,//依赖于sqlSessionFactoryBean 默认bean的id是它,通过MapperFactoryBean创建mapper映射器,当执行这个mapper接口的方法是,通过代理默认得到这个//方法的全限定名称,去找相应的标签进行执行,他的功能就是定位标签的位置@EnableTransactionManagement//开启事务管理器public class SpringConfig &#123; @Bean //配置数据源 public DataSource dataSource()&#123; HikariDataSource dataSource=new HikariDataSource(); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/mvcmybatis?serverTimezone=UTC&quot;); dataSource.setPassword(&quot;root&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); return dataSource; &#125; @Bean //创建mybatis配置类 public org.apache.ibatis.session.Configuration configuration()&#123; org.apache.ibatis.session.Configuration c=new org.apache.ibatis.session.Configuration(); c.setUseGeneratedKeys(true); c.addMappers(&quot;org.ax.mapper&quot;); c.setMapUnderscoreToCamelCase(true); c.setAutoMappingBehavior(AutoMappingBehavior.FULL); return c; &#125; @SneakyThrows @Bean //加载mybatis配置和映射文件 public SqlSessionFactoryBean sqlSessionFactoryBean()&#123; SqlSessionFactoryBean s=new SqlSessionFactoryBean(); s.setConfiguration(configuration()); s.setTypeAliasesPackage(&quot;org.ax.pojo&quot;); s.setDataSource(dataSource()); s.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper/*.xml&quot;)); return s; &#125; @Bean //配置事务管理器 public DataSourceTransactionManager dataSourceTransactionManager()&#123; DataSourceTransactionManager d=new DataSourceTransactionManager(); d.setDataSource(dataSource()); return d; &#125;&#125; 3.配置springmvc12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Configuration //这个是spring的配置类@EnableWebMvc//开启springmvc的配置@ComponentScan(&quot;org.ax.controller&quot;)//扫描控制器@EnableCaching//开启spring提供的缓存,来缓存处理器(handler)@Import(AfterNotice.class)//将通知类纳入容器@EnableAspectJAutoProxy//开启注解的注入通知public class WebMvcConfig implements WebMvcConfigurer &#123; @Bean//配置视图解析器 public InternalResourceViewResolver internalResourceViewResolver()&#123; InternalResourceViewResolver r=new InternalResourceViewResolver(); r.setPrefix(&quot;/WEB-INF/page/&quot;); r.setSuffix(&quot;.jsp&quot;); return r; &#125; @Override //添加虚拟路径和物理路径的映射 public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;/webjars/&quot;); &#125; @Bean //声明缓存区域 public ConcurrentMapCacheManager concurrentMapCacheManager()&#123; ConcurrentMapCacheManager c=new ConcurrentMapCacheManager(); List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add(&quot;role&quot;); list.add(&quot;roleList&quot;); c.setCacheNames(list); return c; &#125; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;// converters.add(jackson()); converters.add(fastJson()); &#125; @Bean //Jackson配置方式 public MappingJackson2HttpMessageConverter jackson()&#123; MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); jackson2HttpMessageConverter.setDefaultCharset(Charset.forName(&quot;utf-8&quot;)); ObjectMapper objectMapper = new ObjectMapper(); JavaTimeModule timeModule = new JavaTimeModule();// 配置时间格式 timeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;))); timeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))); objectMapper.registerModule(timeModule); StringHttpMessageConverter s=new StringHttpMessageConverter(); //设置字符转化器 s.setDefaultCharset(Charset.forName(&quot;utf-8&quot;)); jackson2HttpMessageConverter.setObjectMapper(objectMapper); return jackson2HttpMessageConverter; &#125; @Bean //配置阿里的fastJson数据格式 public FastJsonHttpMessageConverter fastJson()&#123; //1.需要定义一个convert转换消息的对象; FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();// fastJsonHttpMessageConverter.setDefaultCharset(Charset.forName(&quot;utf-8&quot;));//json字符编码 //2.添加fastJson的配置信息，比如：是否要格式化返回的json数据; FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);// fastJsonConfig.setCharset(Charset.forName(&quot;utf-8&quot;)); fastJsonConfig.setDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); //3处理中文乱码问题 List&lt;MediaType&gt; fastMediaTypes = new ArrayList&lt;&gt;(); fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8); //4.在convert中添加配置信息. fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes); fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig); return fastJsonHttpMessageConverter; &#125;&#125; 4.加载spring和springmvc1.配置类方式去加载12345678910111213141516public class LoaderSpringAndWebConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;;//加载载springConfig &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebMvcConfig.class&#125;;//记载springMVcConfig &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; //dispatcheServlet处理的请求范围 &#125;&#125; 2.web.xml方式去加载123456789101112131415161718192021222324252627282930313233343536373839&lt;/web-app&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;listener&gt;&lt;!-- 防止重复加载，出现多个对象 web容器启动时,默认会加载相对路径下的application.xml文件--&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 接受带注解的类作为输入 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 指明配置配的路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;org.ax.config.SpringConfig&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 加载springmvc容器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;org.ax.config.WebConfig&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-01-24T01:53:56.936Z","updated":"2021-01-24T01:53:56.936Z","comments":true,"path":"2021/01/24/hello-world/","link":"","permalink":"https://ipvb.gitee.io/blog/2021/01/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}